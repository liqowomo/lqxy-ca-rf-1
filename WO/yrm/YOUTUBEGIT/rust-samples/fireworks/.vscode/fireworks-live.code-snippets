{
    "0010-allow-dead-code": {
        "prefix": "rs",
        "body": [
            "#[allow(dead_code)]"
        ]
    },
    "0015-dependencies": {
        "prefix": "rs",
        "body": [
            "wasm-bindgen = { version = \"0.2.63\", features = [\"serde-serialize\"] }",
            "js-sys = \"0.3.50\"",
            "serde = { version = \"1.0\", features = [\"derive\"] }",
            "web-sys = { version = \"0.3.50\", features = [\"console\"], optional = true }",
            "console_error_panic_hook = { version = \"0.1.6\", optional = true }",
            "wee_alloc = { version = \"0.4.5\", optional = true }"
        ]
    },
    "0017-usings": {
        "prefix": "rs",
        "body": [
            "use std::ops::AddAssign;",
            "use js_sys::Math::*;",
            "use wasm_bindgen::prelude::*;",
            "use serde::{Serialize, Deserialize};",
            "",
            "#[cfg(feature = \"console_log\")]",
            "use web_sys::console;"
        ]
    },
    "0020-constants": {
        "prefix": "rs",
        "body": [
            "// Try 1 to see exception from Result",
            "static MAX_ROCKETS: usize = 100;",
            "static PARTICLES_PER_ROCKET: usize = 300;",
            "static PARTICLE_LIFESPAN: f64 = 150f64;"
        ]
    },
    "0030-rocket-struct": {
        "prefix": "rs",
        "body": [
            "// Represents a rocket. Note use of serde for JSON support",
            "#[derive(Serialize, Deserialize)]",
            "pub struct Rocket {",
            "    pub rgb: u32,",
            "    pub x: f64,",
            "    pub height: f64,",
            "}"
        ]
    },
    "0040-rocket-state": {
        "prefix": "rs",
        "body": [
            "// Note `wasm_bindgen` macro here. Generates the necessary code",
            "// that makes type available in JS.",
            "#[wasm_bindgen]",
            "#[repr(u8)]",
            "#[derive(Clone, Copy, PartialEq, Eq)]",
            "pub enum RocketState {",
            "    Inactive = 0,",
            "    Rising = 1,",
            "    Exploded = 2,",
            "}",
            "",
            "// Note the implementation of a \"Trait\". In this case, we implement",
            "// the `Default` trait (https://doc.rust-lang.org/std/default/trait.Default.html).",
            "impl Default for RocketState {",
            "    fn default() -> Self {",
            "        RocketState::Inactive",
            "    }",
            "}"
        ]
    },
    "0050-vec-rocket-states": {
        "prefix": "rs",
        "body": [
            "// In our application, we will use a vector of states, so we define",
            "// a type for that.",
            "type States = Vec<RocketState>;",
            "",
            "// When we have our own type, we can add our own traits. Here,",
            "// we are going to add a method that finds the index of the first",
            "// inactive rocket in our buffer of rockets.",
            "trait StatesExt {",
            "    fn first_inactive(&self) -> Result<usize, JsValue>;",
            "}",
            "",
            "impl StatesExt for States {",
            "    /// Returns the index of the first inactive rocket",
            "    ///",
            "    /// Returns the index of the first inactive rocket. If there is",
            "    /// no inactive rocket, the method returns an error.",
            "    fn first_inactive(&self) -> Result<usize, JsValue> {",
            "        // Note the use of an iterator in the next line",
            "        let free_index = self.iter().position(|&s| s == RocketState::Inactive);",
            "",
            "        // Note match syntax over an Option enum.",
            "        match free_index {",
            "            None => Err(\"No inactive element\".into()),",
            "            Some(ix) => Result::Ok(ix),",
            "        }",
            "    }",
            "}"
        ]
    },
    "0060-particle-states": {
        "prefix": "rs",
        "body": [
            "#[wasm_bindgen]",
            "#[repr(u8)]",
            "#[derive(Clone, Copy, Debug, PartialEq, Eq)]",
            "pub enum ParticleState {",
            "    Inactive = 0,",
            "    Active = 1,",
            "}",
            "",
            "impl Default for ParticleState {",
            "    fn default() -> Self {",
            "        ParticleState::Inactive",
            "    }",
            "}",
        ]
    },
    "0070-vector-2d": {
        "prefix": "rs",
        "body": [
            "#[wasm_bindgen]",
            "#[derive(Clone, Default, Copy)]",
            "pub struct Vector2d {",
            "    x: f64,",
            "    y: f64,",
            "}",
            "",
            "// Implement `AddAssign` trait in order to get `+=` operator ",
            "// for `Vector2d` (https://doc.rust-lang.org/std/ops/trait.AddAssign.html)",
            "impl AddAssign for Vector2d {",
            "    fn add_assign(&mut self, other: Self) {",
            "        *self = Self {",
            "            x: self.x + other.x,",
            "            y: self.y + other.y,",
            "        };",
            "    }",
            "}"
        ]
    },
    "0080-some-parameters": {
        "prefix": "rs",
        "body": [
            "#[wasm_bindgen]",
            "#[derive(Default, Clone)]",
            "pub struct RocketColor {",
            "    red: u8,",
            "    green: u8,",
            "    blue: u8,",
            "}",
            "",
            "#[wasm_bindgen]",
            "#[derive(Default, Clone)]",
            "pub struct RocketParameter {",
            "    spread: f64,",
            "    velocity: f64,",
            "    acceleration: f64,",
            "}",
            "",
            "#[wasm_bindgen]",
            "#[derive(Default, Clone)]",
            "pub struct ParticleParameter {",
            "    velocity: Vector2d,",
            "    lifespan: f64,",
            "    lifespan_diff: f64,",
            "    acceleration: f64,",
            "}"
        ]
    },
    "0090-firework-struct": {
        "prefix": "rs",
        "body": [
            "#[wasm_bindgen]",
            "#[derive(Default)]",
            "pub struct Firework {",
            "    rocket_states: States,",
            "    colors: Vec<RocketColor>,",
            "    rockets: Vec<Vector2d>,",
            "    parameters: Vec<RocketParameter>,",
            "    particle_states: Vec<ParticleState>,",
            "    particles: Vec<Vector2d>,",
            "    particle_parameters: Vec<ParticleParameter>,",
            "}"
        ]
    },
    "0100-constructor": {
        "prefix": "rs",
        "body": [
            "#[wasm_bindgen]",
            "impl Firework {",
            "    /// Create a new firework",
            "    pub fn new() -> Firework {",
            "        Firework {",
            "            rocket_states: vec![Default::default(); MAX_ROCKETS],",
            "            colors: vec![Default::default(); MAX_ROCKETS],",
            "            rockets: vec![Default::default(); MAX_ROCKETS],",
            "            parameters: vec![Default::default(); MAX_ROCKETS],",
            "            particle_states: vec![Default::default(); MAX_ROCKETS * PARTICLES_PER_ROCKET],",
            "            particles: vec![Default::default(); MAX_ROCKETS * PARTICLES_PER_ROCKET],",
            "            particle_parameters: vec![Default::default(); MAX_ROCKETS * PARTICLES_PER_ROCKET],",
            "        }",
            "    }",
            "}"
        ]
    },
    "0110-add-rocket-low-level": {
        "prefix": "rs",
        "body": [
            "/// Add a rocket",
            "///",
            "/// # Arguments",
            "/// ",
            "/// * `red` - Red portion of RGB color (0..255)",
            "/// * `green` - Green portion of RGB color (0..255)",
            "/// * `blue` - Green portion of RGB color (0..255)",
            "/// * `x` - x coordinate where rocket should rise",
            "/// * `height` - Approximate height to which the rocket should rise before exploding",
            "///",
            "/// # Remarks",
            "///",
            "/// Throws an exception if all available rocket slots are currently in use.",
            "pub fn add(&mut self, red: u8, green: u8, blue: u8, x: f64, height: f64) -> Result<(), JsValue> {",
            "    // Note the `?` at the end of the line. Will return an error",
            "    // if `first_inactive` returned an error.",
            "    let free_index = self.rocket_states.first_inactive()?;",
            "",
            "    // Calculate rocket parameters",
            "    let p = RocketParameter {",
            "        spread: random() * 20f64 + 10f64,",
            "        velocity: (height.sqrt() * -1f64) / 2f64 * height / 100f64,",
            "        acceleration: 0f64,",
            "    };",
            "    let c = RocketColor { red, green, blue };",
            "    let r = Vector2d { x, y: 0f64 };",
            "",
            "    // Set rocket parameters",
            "    self.rocket_states[free_index] = RocketState::Rising;",
            "    self.colors[free_index] = c;",
            "    self.rockets[free_index] = r;",
            "    self.parameters[free_index] = p;",
            "",
            "    // Note how we conditionally call JavaScript's console.log",
            "    #[cfg(feature = \"console_log\")]",
            "    console::log_2(&\"Added ðŸš€ at index \".into(), &free_index.to_string().into());",
            "",
            "    Result::Ok(())",
            "}"
        ]
    },
    "0120-add-rocket-json": {
        "prefix": "rs",
        "body": [
            "// Note the use of JsValue. Read more at ",
            "// https://rustwasm.github.io/wasm-bindgen/api/wasm_bindgen/struct.JsValue.html",
            "pub fn add_rocket(&mut self, rocket: &JsValue) -> Result<(), JsValue> {",
            "    // Note deserialization of JSON using Serde",
            "    let rocket: Rocket = rocket.into_serde().unwrap();",
            "",
            "    self.add(((rocket.rgb & 0xff0000u32) >> 8 >> 8) as u8, ((rocket.rgb & 0xff00u32) >> 8) as u8, (rocket.rgb & 0xffu32) as u8, rocket.x, rocket.height)?;",
            "",
            "    Result::Ok(())",
            "}"
        ]
    },
    "0130-js-fireworks-new": {
        "prefix": "rs",
        "body": [
            "import * as fw from \"fireworks-sample\";",
            "import { memory } from \"fireworks-sample/fireworks_sample_bg.wasm\";",
            "import * as p5 from 'p5';",
            "",
            "const firework = fw.Firework.new();"
        ]
    },
    "0140-js-p5-draw": {
        "prefix": "rs",
        "body": [
            "async function setup(p) {",
            "    p.createCanvas(p.windowWidth, p.windowHeight);",
            "",
            "    // Add rockets",
            "    firework.add_rocket({ rgb: 0x00ff00, x: Math.random() * p.windowWidth, height: 170 });",
            "    setInterval(() => {",
            "        firework.add(Math.random() * 256, Math.random() * 256, Math.random() * 256, Math.random() * p.windowWidth, Math.random() * 100 + 100);",
            "    }, 300);",
            "}",
            "",
            "function draw(p) {",
            "    p.colorMode(p.RGB);",
            "    p.background(0, 0, 0, 25);",
            "}",
            "",
            "const p = new p5((p) => {",
            "    p.setup = () => setup(p);",
            "    p.draw = () => draw(p);",
            "    return p;",
            "});"
        ]
    },
    "0150-get-buffer-ptrs": {
        "prefix": "rs",
        "body": [
            "// Calculate index of praticle based on rocket and particle ID",
            "pub fn get_particle_index(rix: usize, pix: usize) -> usize {",
            "    rix * PARTICLES_PER_ROCKET + pix",
            "}",
            "",
            "/// Get size of rocket buffer",
            "#[wasm_bindgen(getter)]",
            "pub fn rocket_buffer_size(&self) -> usize {",
            "    MAX_ROCKETS",
            "}",
            "",
            "/// Get size of rocket buffer",
            "#[wasm_bindgen(getter)]",
            "pub fn particle_buffer_size(&self) -> usize {",
            "    MAX_ROCKETS * PARTICLES_PER_ROCKET",
            "}",
            "",
            "/// Get buffer of rocket coordinates",
            "pub fn rockets(&self) -> *const Vector2d {",
            "    self.rockets.as_ptr()",
            "}",
            "",
            "/// Get buffer of rocket colors",
            "pub fn colors(&self) -> *const RocketColor {",
            "    self.colors.as_ptr()",
            "}",
            "",
            "/// Get buffer of rocket states",
            "pub fn states(&self) -> *const RocketState {",
            "    self.rocket_states.as_ptr()",
            "}",
            "",
            "/// Get buffer of particle states",
            "pub fn particle_states(&self) -> *const ParticleState {",
            "    self.particle_states.as_ptr()",
            "}",
            "",
            "/// Get buffer of particle coordinates",
            "pub fn particles(&self) -> *const Vector2d {",
            "    self.particles.as_ptr()",
            "}",
            "",
            "/// Get max particles per rocket",
            "pub fn get_max_particles_per_rocket(&self) -> usize {",
            "    PARTICLES_PER_ROCKET",
            "}"
        ]
    },
    "0160-js-access-buffers": {
        "prefix": "rs",
        "body": [
            "// Get buffers",
            "const colors = new Uint8Array(memory.buffer, firework.colors(), firework.rocket_buffer_size * 3);",
            "const rockets = new Float64Array(memory.buffer, firework.rockets(), firework.rocket_buffer_size * 2);",
            "const states = new Uint8Array(memory.buffer, firework.states(), firework.rocket_buffer_size);",
            "",
            "const particles = new Float64Array(memory.buffer, firework.particles(), firework.particle_buffer_size * 2);",
            "const particle_states = new Uint8Array(memory.buffer, firework.particle_states(), firework.particle_buffer_size);"
        ]
    },
    "0170-apply-force": {
        "prefix": "rs",
        "body": [
            "/// Calculate new rocket state",
            "pub fn apply_force(&mut self) {",
            "    // Iterate over all rockets",
            "    for rix in 0..self.rockets.len() {",
            "        // Ignore inactive rockets",
            "        let rocket_state = self.rocket_states[rix];",
            "        if rocket_state == RocketState::Inactive {",
            "            continue;",
            "        }",
            "",
            "        // Borrow mutable parameter of current rocket and calculate",
            "        // new values for y coordinate and parameters.",
            "        let parameter = &mut self.parameters[rix];",
            "        self.rockets[rix].y += parameter.velocity;",
            "        parameter.velocity += parameter.acceleration;",
            "        parameter.acceleration += 0.005f64;",
            "",
            "        // Check if rocket has started to fall down again -> let it explode",
            "        if parameter.velocity > 0f64 && rocket_state == RocketState::Rising {",
            "            self.explode(rix);",
            "        }",
            "",
            "        // If rocket has exploded, deal with particles",
            "        if self.rocket_states[rix] == RocketState::Exploded {",
            "            let mut at_least_one_particle_active = false;",
            "            for pix in 0..PARTICLES_PER_ROCKET {",
            "                // Calculate global index of particle. Note shadowing again.",
            "                let pix = rix * PARTICLES_PER_ROCKET + pix;",
            "",
            "                // Ignore inactive particles",
            "                if self.particle_states[pix] == ParticleState::Inactive {",
            "                    continue;",
            "                }",
            "",
            "                // Note use of operator overloading",
            "                self.particles[pix] += self.particle_parameters[pix].velocity;",
            "",
            "                // Borrow mutable parameter of current particle and calculate new values.",
            "                let parameter = &mut self.particle_parameters[pix];",
            "                parameter.velocity.y += parameter.acceleration;",
            "                parameter.acceleration += 0.005f64;",
            "                parameter.velocity.x *= 0.9f64;",
            "                parameter.velocity.y *= 0.9f64;",
            "                parameter.lifespan -= parameter.lifespan_diff;",
            "",
            "                if parameter.lifespan <= 0f64 {",
            "                    self.particle_states[pix] = ParticleState::Inactive;",
            "                } else {",
            "                    // Found at least one particle which is still active",
            "                    at_least_one_particle_active = true;",
            "                }",
            "            }",
            "",
            "            if !at_least_one_particle_active {",
            "                // No more active particles -> rocket becomes inactive",
            "                self.rocket_states[rix] = RocketState::Inactive;",
            "            }",
            "        }",
            "    }",
            "}"
        ]
    },
    "0180-explosions": {
        "prefix": "rs",
        "body": [
            "",
            "impl Firework {",
            "    /// Adds a particle for a rocket",
            "    ///",
            "    /// # Arguments",
            "    ///",
            "    /// * `rix` - zero-based index of rocket",
            "    /// * `pix` - zero-based particle index",
            "    pub fn add_particle(&mut self, rix: usize, pix: usize) {",
            "        // Every particle starts at position where rocket exploded",
            "        let r = self.rockets[rix];",
            "",
            "        // Note the use of a local function",
            "        fn rand_velocity(spread: f64) -> f64 {",
            "            (random() * 2f64 - 1f64) * random() * spread",
            "        }",
            "",
            "        let spread = self.parameters[rix].spread;",
            "        let p = ParticleParameter {",
            "            velocity: Vector2d {",
            "                x: rand_velocity(spread),",
            "                y: rand_velocity(spread),",
            "            },",
            "            lifespan: PARTICLE_LIFESPAN,",
            "            lifespan_diff: random() * 6.5f64 + 1.5f64,",
            "            acceleration: 0f64,",
            "        };",
            "",
            "        // Calculate particle index",
            "        // Note \"shadowing\" of local variable pix here.",
            "        let pix = rix * PARTICLES_PER_ROCKET + pix;",
            "",
            "        // Set particle state, position, and parameters",
            "        self.particle_states[pix] = ParticleState::Active;",
            "        self.particles[pix] = r;",
            "        self.particle_parameters[pix] = p;",
            "    }",
            "",
            "    /// Let rocket explode",
            "    ///",
            "    /// # Arguments",
            "    ///",
            "    /// * `rix` - zero-based index of rocket",
            "    pub fn explode(&mut self, rix: usize) {",
            "        // Generate particles for exploding rocket",
            "        for pix in 0..PARTICLES_PER_ROCKET {",
            "            self.add_particle(rix, pix);",
            "        }",
            "",
            "        // Note how we conditionally call JavaScript's console.log",
            "        #[cfg(feature = \"console_log\")]",
            "        console::log_3(&\"Rocket \".into(), &rix.to_string().into(), &\" exploded\".into());",
            "",
            "        // Change rocket state to exploded",
            "        self.rocket_states[rix] = RocketState::Exploded;",
            "    }",
            "}"
        ]
    },
    "0190-js-draw-impl": {
        "prefix": "rs",
        "body": [
            "// Recalculate positions and parameters",
            "firework.apply_force();",
            "",
            "for (let r = firework.rocket_buffer_size - 1; r >= 0; r--) {",
            "    if (states[r] === fw.RocketState.Inactive) continue;",
            "",
            "    p.stroke(colors[r * 3], colors[r * 3 + 1], colors[r * 3 + 2]);",
            "",
            "    if (states[r] === fw.RocketState.Rising) {",
            "        p.strokeWeight(4);",
            "        p.point(rockets[r * 2], p.height + rockets[r * 2 + 1]);",
            "    } else {",
            "        p.strokeWeight(2.5);",
            "        for (let pix = firework.get_max_particles_per_rocket() - 1; pix >= 0; pix--) {",
            "            if (particle_states[fw.Firework.get_particle_index(r, pix)] === fw.ParticleState.Inactive) continue;",
            "            p.point(particles[fw.Firework.get_particle_index(r, pix) * 2], p.height + particles[fw.Firework.get_particle_index(r, pix) * 2 + 1]);",
            "        }",
            "    }",
            "}"
        ]
    }
}